==> test/AllSeqTypes.out <==
Usage:
  demo [optional-params] [args]
demo entry point with parameters of all basic types.
  Options(opt-arg sep :|=|spc):
  -h, --help                            write this help to stdout
  -b=, --bl=  ,SV[bool]     EMPTY       set bl
  -B=, --Bl=  ,SV[bool]     false,true  set Bl
  -s=, --s=   ,SV[string]   EMPTY       set s
  -S=, --S=   ,SV[string]   ho,hey      set S
  -i=, --i=   ,SV[int]      EMPTY       set i
  -I=, --I=   ,SV[int]      1,2         set I
  --i1=       ,SV[int8]     EMPTY       set i1
  --I1=       ,SV[int8]     3,4         set I1
  --i2=       ,SV[int16]    EMPTY       set i2
  --I2=       ,SV[int16]    5,6         set I2
  --i4=       ,SV[int32]    EMPTY       set i4
  --I4=       ,SV[int32]    7,8         set I4
  --i8=       ,SV[int64]    EMPTY       set i8
  --I8=       ,SV[int64]    9,10        set I8
  -u=, --u=   ,SV[uint]     EMPTY       set u
  -U=, --U=   ,SV[uint]     11,12       set U
  --u1=       ,SV[uint8]    EMPTY       set u1
  --U1=       ,SV[uint8]    13,14       set U1
  --u2=       ,SV[uint16]   EMPTY       set u2
  --U2=       ,SV[uint16]   15,16       set U2
  --u4=       ,SV[uint32]   EMPTY       set u4
  --U4=       ,SV[uint32]   17,18       set U4
  --u8=       ,SV[uint64]   EMPTY       set u8
  --U8=       ,SV[uint64]   19,20       set U8
  -f=, --f4=  ,SV[float32]  EMPTY       set f4
  -F=, --F4=  ,SV[float32]  23.0,24.0   set F4
  --f8=       ,SV[float]    EMPTY       set f8
  --F8=       ,SV[float]    25.0,26.0   set F8

==> test/AllSetTypes.out <==
Usage:
  demo [optional-params] [args]
demo entry point with parameters of all basic types.
  Options(opt-arg sep :|=|spc):
  -h, --help                               write this help to stdout
  -b=, --bl=  ,SV[bool]    EMPTY           set bl
  -B=, --Bl=  ,SV[bool]    false,true      set Bl
  -i=, --i1=  ,SV[int8]    EMPTY           set i1
  -I=, --I1=  ,SV[int8]    3,4             set I1
  --i2=       ,SV[int16]   EMPTY           set i2
  --I2=       ,SV[int16]   5,6             set I2
  -u=, --u1=  ,SV[uint8]   EMPTY           set u1
  -U=, --U1=  ,SV[uint8]   13,14           set U1
  --u2=       ,SV[uint16]  EMPTY           set u2
  --U2=       ,SV[uint16]  15,16           set U2
  -e=, --e=   ,SV[Color]   EMPTY           set e
  -E=, --E=   ,SV[Color]   red,green,blue  set E

==> test/AllTypes.out <==
Usage:
  demo [optional-params] [args]
demo entry point with parameters of all basic types.
  Options(opt-arg sep :|=|spc):
  -?, --help                  write this help to stdout
  -a, --aa    bool     false  set aa
  -b=, --bb=  string   "hi"   set bb
  -c=, --cc=  string   "ho"   set cc
  -d=, --dd=  char     'X'    set dd
  -e=, --ee=  int      1      set ee
  -f=, --ff=  int8     2      set ff
  -g=, --gg=  int16    3      set gg
  -h=, --hh=  int32    4      set hh
  -i=, --ii=  int64    5      set ii
  -j=, --jj=  uint     6      set jj
  -k=, --kk=  uint8    7      set kk
  -l=, --ll=  uint16   8      set ll
  -m=, --mm=  uint32   9      set mm
  -n=, --nn=  uint64   10     set nn
  -o=, --oo=  float    11.0   set oo
  -p=, --pp=  float32  12.0   set pp
  -q=, --qq=  float    13.0   set qq

==> test/BlockedShort.out <==
Usage:
  demo [optional-params]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                 write this help to stdout
  --alpha=    int     1      set alpha
  --abc=      float   2.0    set abc
  -a, --aaah  bool    false  set aaah
  --aloha=    string  ""     set aloha

==> test/CaseDistinguised.out <==
Usage:
  demo [optional-params]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    write this help to stdout
  -z=, --alpha=  int     1      set alpha
  -A=, --Abc=    float   2.0    set Abc
  -a, --aaah     bool    false  set aaah
  --aloha=       string  ""     set aloha

==> test/CustomCmdName.out <==
Usage:
  deeeemo [optional-params] [args]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    write this help to stdout
  -a=, --alpha=  int     1      set alpha
  -b=, --beta=   float   2.0    set beta
  -v, --verb     bool    false  set verb
  -i=, --item=   string  ""     set item

==> test/CustomType.out <==
Usage:
  demo [optional-params] [args]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    write this help to stdout
  -a=, --alpha=  int   1        set alpha
  -v, --verb     bool  false    set verb
  -s=, --stuff=  CSV   "ab,cd"  set stuff

==> test/DetectSet.out <==
Usage:
  foo [optional-params]
  Options(opt-arg sep :|=|spc):
  -h, --help             write this help to stdout
  -a=, --alpha=  int  1  set alpha
  -b=, --beta=   int  2  set beta

==> test/DupShort.out <==
Usage:
  demo [optional-params]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    write this help to stdout
  -z=, --alpha=  int     1      set alpha
  -a=, --abc=    float   2.0    set abc
  --aaah         bool    false  set aaah
  --aloha=       string  ""     set aloha

==> test/EarlySeq.out <==
Usage:
  demo [optional-params] [args]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    write this help to stdout
  -a=, --alpha=  int     1      set alpha
  -b=, --beta=   float   2.0    set beta
  -v, --verb     bool    false  set verb
  -i=, --item=   string  ""     set item

==> test/EchoResult.out <==
Usage:
  editDistanceAscii [required&optional-params]
Returns the edit distance between `a` and `b`.

This uses the `Levenshtein`:idx: distance algorithm with only a linear
memory overhead.
  Options(opt-arg sep :|=|spc):
  -h, --help                    write this help to stdout
  -a=, --a=   string  REQUIRED  set a
  -b=, --b=   string  REQUIRED  set b

==> test/Enums.out <==
Usage:
  demo [optional-params] [args]
demo entry point with varied, meaningless parameters.
  Options(opt-arg sep :|=|spc):
  -h, --help                          write this help to stdout
  -b=, --bg=       enum        red    background color
  -f=, --fgs=      ,SV[Color]  green  foreround colors
  -c=, --cursors=  ,SV[Color]  blue   cursor colors
  -x=, --x=        int         0      set x

==> test/External.out <==
Usage:
  demo [optional-params] [args]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    write this help to stdout
  -a=, --alpha=  int     1      set alpha
  -b=, --beta=   float   2.0    set beta
  -v, --verb     bool    false  set verb
  -i=, --item=   string  ""     set item

==> test/FancyRepeats.out <==
Usage:
  demo [optional-params] [args]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                         write this help to stdout
  -a=, --alpha=  int          1      set alpha
  -v=, --verb=   countr       0      set verb
  -j=, --junk=   ,SV[string]  rs,tu  set junk
  -s=, --stuff=  ,SV[string]  ab,cd  set stuff

==> test/FullyAutoMulti.out <==
Usage:
  FullyAutoMulti {subcommand}
where {subcommand} is one of:
  help demo print whoa nelly
Run top-level cmd with -h or --help for top-level help.
Run top-level with subcmd "help" to get *all* helps.
Run any given subcommand with --help to see help for that one.
Top-level --version also available

==> test/FullyAutoMultiTopLvl.out <==
Usage:  This is a multiple-dispatch cmd.  Usage is like
  FullyAutoMulti subcommand [subcommand-opts & args]
where subcommand syntaxes are as follows:

  demo [optional-params] [files]
    demo entry point with varied, meaningless parameters.
    Options(opt-arg sep :|=|spc):
      -h, --help                    write this help to stdout
      -a=, --alpha=  int     1      set alpha
      -b=, --beta=   float   2.0    set beta
      -v, --verb     bool    false  on=chatty, off=quiet
      -i=, --item=   string  ""     set item
  
  print [optional-params] [paths]
    show entry point with varied, meaningless parameters.
    Options(opt-arg sep :|=|spc):
      -h, --help                   write this help to stdout
      -z=, --gamma=  int    1      set gamma
      -i=, --iota=   float  2.0    set iota
      -v, --verb     bool   false  set verb
  
  whoa [optional-params] [names]
    Another entry point; here we echoResult
    Options(opt-arg sep :|=|spc):
      -h, --help                  write this help to stdout
      -z=, --zeta=  int    1      set zeta
      -e=, --eta=   float  2.0    set eta
      -v, --verb    bool   false  set verb
  
  nelly [optional-params] [names]
    Yet another entry point; here we block autoEcho
    Options(opt-arg sep :|=|spc):
      -h, --help                  write this help to stdout
      --hooves=      int   4      set hooves
      -r=, --races=  int   9      set races
      -v, --verb     bool  false  set verb

==> test/HashSets.out <==
Usage:
  demo [optional-params] [args]
demo entry point with parameters of all basic types.
  Options(opt-arg sep :|=|spc):
  -h, --help                               write this help to stdout
  -i=, --i1=  ,SV[int8]    EMPTY           set i1
  -I=, --I1=  ,SV[int8]    3,4             set I1
  --i2=       ,SV[int16]   EMPTY           set i2
  --I2=       ,SV[int16]   5,6             set I2
  -u=, --u1=  ,SV[uint8]   EMPTY           set u1
  -U=, --U1=  ,SV[uint8]   13,14           set U1
  --u2=       ,SV[uint16]  EMPTY           set u2
  --U2=       ,SV[uint16]  16,15           set U2
  -e=, --e=   ,SV[Color]   EMPTY           set e
  -E=, --E=   ,SV[Color]   red,green,blue  set E

==> test/HelpTabCols.out <==
Usage:
  demo [optional-params] [args]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help     write this help to stdout  
  -z=, --alpha=  growth constant            1
  -b=, --beta=   shrink target              2.0
  -v, --verb     set verb                   false
  -i=, --item=   set item                   ""

==> test/ImplicitDefault.out <==
Usage:
  demo [required&optional-params] [args]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                       write this help to stdout
  -a=, --alpha=  int     REQUIRED  set alpha
  -b, --bypass   bool    false     set bypass
  -i=, --item=   string  ""        set item

==> test/ListDecl.out <==
Usage:
  demo [required&optional-params] [args]
demo entry point with varied, meaningless parameters.
  Options(opt-arg sep :|=|spc):
  -h, --help                      write this help to stdout
  -a=, --alpha=  float  REQUIRED  set alpha
  -b=, --beta=   float  1.0       set beta
  -v, --verb     bool   false     set verb

==> test/Mandatory.out <==
Usage:
  demo [required&optional-params] [args]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                       write this help to stdout
  -a=, --alpha=  int     REQUIRED  set alpha
  -b=, --beta=   float   2.0       set beta
  -v, --verb     bool    false     set verb
  -i=, --item=   string  REQUIRED  set item

==> test/MandatoryNoPos.out <==
Usage:
  demo [required&optional-params]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                       write this help to stdout
  -a=, --alpha=  int     REQUIRED  set alpha
  -b=, --beta=   float   2.0       set beta
  -v, --verb     bool    false     set verb
  -i=, --item=   string  REQUIRED  set item

==> test/ManualMulti.out <==
Usage:
  ManualMulti demo|show [subcommand-args]

    This is a multiple-dispatch cmd.  Subcommand syntax:

    ManualMulti demo [optional-params] [files]
          This does the demo.
    
    Options:
          -h, --help                    write this help to stdout
          -a=, --alpha=  int     1      This is a very long parameter help
                                        string which ordinarily should be
                                        auto-wrapped by alignTable into a
                                        multi-line format unless you have eagle
                                        eyes, a gigantic monitor, or maybe a
                                        little bit of both. :-)
          -b=, --beta=   float   2.0    This is more modest, but might still
                                        wrap around once or twice or so.
          -v, --verb     bool    false  on=chatty, off=quiet. 'Nuff said.
          -i=, --item=   string  ""     set item

    ManualMulti show [optional-params] [paths]
          This shows me something.
    
    Options:
          -h, --help                   write this help to stdout
          -g=, --gamma=  int    1      set gamma
          -i=, --iota=   float  2.0    set iota
          -v, --verb     bool   false  set verb

==> test/MultiFlag.out <==
Usage:
  demo [optional-params] [args]
demo entry point with varied, meaningless parameters.
  Options(opt-arg sep :|=|spc):
  -h, --help                 write this help to stdout
  -a, --alpha   bool  true   set alpha
  -b=, --beta=  int   2      set beta
  -v, --verb    bool  false  set verb

==> test/NoPositional.out <==
Usage:
  demo [optional-params]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    write this help to stdout
  -a=, --alpha=  int     1      set alpha
  -b=, --beta=   float   2.0    set beta
  -v, --verb     bool    false  set verb
  -i=, --item=   string  ""     set item

==> test/NoShort.out <==
Usage:
  demo [optional-params]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                 write this help to stdout
  --alpha=    int     1      set alpha
  --abc=      float   2.0    set abc
  --aaah      bool    false  set aaah
  --aloha=    string  ""     set aloha

==> test/OneCharParams.out <==
Usage:
  demo [optional-params] [b]
This tests if single character parameters work as expected
  Options(opt-arg sep :|=|spc):
  -h, --help                      write this help to stdout
  -u=, --u=   int     1           set u
  -c=, --c=   string  "bad name"  set c
  -g=, --g=   string  "ho"        set g

==> test/PerParam.out <==
Usage:
  demo [optional-params] [args]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    write this help to stdout
  -z=, --alpha=  int     1      growth constant
  -b=, --beta=   float   2.0    shrink target
  -v, --verb     bool    false  set verb
  -i=, --item=   string  ""     set item

==> test/ResultInt.out <==
Usage:
  editDistanceAscii [required&optional-params]
Returns the edit distance between `a` and `b`.

This uses the `Levenshtein`:idx: distance algorithm with only a linear
memory overhead.
  Options(opt-arg sep :|=|spc):
  -h, --help                    write this help to stdout
  --version   bool    false     write version to stdout
  -a=, --a=   string  REQUIRED  set a
  -b=, --b=   string  REQUIRED  set b

==> test/ReturnEmpty.out <==
Usage:
  demo [optional-params] [args]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    write this help to stdout
  -a=, --alpha=  int     1      set alpha
  -b=, --beta=   float   2.0    set beta
  -v, --verb     bool    false  set verb
  -i=, --item=   string  ""     set item

==> test/ReturnInt.out <==
Usage:
  demo [optional-params] [args]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    write this help to stdout
  -a=, --alpha=  int     1      set alpha
  -b=, --beta=   float   2.0    set beta
  -v, --verb     bool    false  set verb
  -i=, --item=   string  ""     set item

==> test/ReturnNonInt.out <==
Usage:
  demo [optional-params] [args]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    write this help to stdout
  -a=, --alpha=  int     1      set alpha
  -b=, --beta=   float   2.0    set beta
  -v, --verb     bool    false  set verb
  -i=, --item=   string  ""     set item

==> test/ReturnNonIntNoAuto.out <==
Usage:
  demo [optional-params] [args]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    write this help to stdout
  -a=, --alpha=  int     1      set alpha
  -b=, --beta=   float   2.0    set beta
  -v, --verb     bool    false  set verb
  -i=, --item=   string  ""     set item

==> test/ReturnString.out <==
Usage:
  demo [optional-params] [args]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    write this help to stdout
  -a=, --alpha=  int     1      set alpha
  -b=, --beta=   float   2.0    set beta
  -v, --verb     bool    false  set verb
  -i=, --item=   string  ""     set item

==> test/SemiAutoMulti.out <==
Usage:
  multi [optional-params] [subcmd]
Run command with no parameters for a full help message.
  Options(opt-arg sep :|=|spc):
  -h, --help                write this help to stdout
  -b=, --beta=  int     1   set beta
  -i=, --item=  string  ""  set item

==> test/SeqInt.out <==
Usage:
  demo [optional-params] [args]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 3 4" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    write this help to stdout
  -a=, --alpha=  int     1      set alpha
  -b=, --beta=   char    '\10'  set beta
  -v, --verb     bool    false  set verb
  -i=, --item=   string  ""     set item

==> test/Suppress.out <==
Usage:
  demo [optional-params] [args]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                 write this help to stdout
  -a=, --alpha=  int    1    growth constant
  -b=, --beta=   float  2.0  shrink target

==> test/TwoNondefaultedSeq.out <==
TwoNondefaultedSeq.nim(9, 11) template/generic instantiation of `dispatch` from here
cligen.nim(111, 16) Warning: cligen only supports one seq param for positional args; using `args`, not `stuff`. [User]
Usage:
  demo [required&optional-params] [args]
demo entry point with varied, meaningless parameters.
  Options(opt-arg sep :|=|spc):
  -h, --help                            write this help to stdout
  -a=, --alpha=  int          1         set alpha
  -v, --verb     bool         false     set verb
  -s=, --stuff=  ,SV[string]  REQUIRED  set stuff

==> test/TwoNondefaultedSeqSwap.out <==
Usage:
  demo [required&optional-params] [stuff]
demo entry point with varied, meaningless parameters.
  Options(opt-arg sep :|=|spc):
  -h, --help                            write this help to stdout
  -a=, --alpha=  int          1         set alpha
  -v, --verb     bool         false     set verb
  --args=        ,SV[string]  REQUIRED  set args

==> test/UserDispIdCollide.out <==
Usage:
  demo [optional-params] [args]
This tests if things work when a wrapped user-proc uses identifiers also
used in our generated dispatch proc.
  Options(opt-arg sep :|=|spc):
  -h, --help                           write this help to stdout
  -u=, --usage=    int     1           set usage
  -c=, --cmdline=  string  "bad name"  set cmdline
  -g=, --getopt=   string  "ho"        set getopt

==> test/Version.out <==
Usage:
  demo [optional-params] [args]
demo entry point with varied, meaningless parameters.  A Nim invocation
might be: demo(alpha=2, @[ "hi", "ho" ]) corresponding to the command
invocation "demo --alpha=2 hi ho" (assuming executable gets named demo).
  Options(opt-arg sep :|=|spc):
  -h, --help                    write this help to stdout
  --version      bool    false  write version to stdout
  -a=, --alpha=  int     1      set alpha
  -i=, --item=   string  "hi"   set item
